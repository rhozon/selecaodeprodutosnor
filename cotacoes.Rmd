---
params:
  symbol1: PBR
  symbol2: VALE
---

<!-- https://bookdown.org/ccolonescu/RPoE4/time-varying-volatility-and-arch-models.html -->

# Introdução

```{r include = FALSE}
library(quantmod)
library(dygraphs)

ativo1 <- getSymbols(params$symbol1, auto.assign = FALSE,
                    from = "2018-01-01", end = Sys.Date())
ativo2 <- getSymbols(params$symbol2, auto.assign = FALSE,
                    from = "2018-01-01", end = Sys.Date())
```


Esse relatório capta dinamicamente as cotações de dois ativos
  
* ``r params$symbol1`` Petrobras
* ``r params$symbol2`` Vale

Os dados são originários do [Yahoo finance](http://finance.yahoo.com). As séries temporais se iniciam em 01/01/2018 e terminam no último valor de fechamento quase que em real time.

### ``r params$symbol1`` price

```{r echo = FALSE}
dygraph(Cl(ativo1))
```

### ``r params$symbol1`` volume

```{r echo = FALSE}
dygraph(Vo(ativo1))
```


A Operação Lava Jato é um conjunto de investigações, algumas controversas, em andamento pela Polícia Federal do Brasil, que cumpriu mais de mil mandados de busca e apreensão, de prisão temporária, de prisão preventiva e de condução coercitiva, visando apurar um esquema de lavagem de dinheiro que movimentou bilhões de reais em propina. A operação teve início em 17 de março de 2014 e conta com 71 fases operacionais autorizadas, entre outros, pelo então juiz Sérgio Moro, durante as quais prenderam-se e condenaram-se mais de cem pessoas. Investiga crimes de corrupção ativa e passiva, gestão fraudulenta, lavagem de dinheiro, organização criminosa, obstrução da justiça, operação fraudulenta de câmbio e recebimento de vantagem indevida. A Lava Jato foi apontada por críticos como uma das causas da crise político-econômica de 2014 no país. De acordo com investigações e delações premiadas, estavam envolvidos em corrupção membros administrativos da empresa estatal petrolífera Petrobras, políticos dos maiores partidos do Brasil, incluindo presidentes da República, presidentes da Câmara dos Deputados e do Senado Federal e governadores de estados, além de empresários de grandes empresas brasileiras. A Polícia Federal considera-a a maior investigação de corrupção da história do país.


### ``r params$symbol2`` price

```{r echo = FALSE}
dygraph(Cl(ativo2)) 
```

### ``r params$symbol2`` volume

```{r echo = FALSE}
dygraph(Vo(ativo2)) 
```


O rompimento de barragem em Brumadinho em 25 de janeiro de 2019 foi o maior acidente de trabalho no Brasil em perda de vidas humanas e o segundo maior desastre industrial do século. Foi um dos maiores desastres ambientais da mineração do país, depois do rompimento de barragem em Mariana.

Controlada pela Vale S.A., a barragem de rejeitos denominada barragem da Mina Córrego do Feijão, era classificada como de "baixo risco" e "alto potencial de danos" pela empresa. Acumulando os rejeitos de um mina de ferro, ficava no ribeirão Ferro-Carvão, na região de Córrego do Feijão, no município de Brumadinho, estado de Minas Gerais.

```{r}
# Gero as primeiras 10 linhas do dataset
ativo2[1:10,]

Cl(ativo2) # Gero os dados para aqueles que desejem baixar por aqui

Vo(ativo2) # Gero os dados para aqueles que desejem baixar por aqui
```

Após vermos os precos de fechamento e volume, obtenho o log retorno dos precos 


```{r}

dlnVALEclose <- diff(log(Cl(ativo2)), lag=1)

dygraph(dlnVALEclose)
```

Agora observo o padrão da distribuição dos log retornos:

```{r}
hist(dlnVALEclose, main="", breaks=20, freq=FALSE, col="grey")
```


Vamos iniciar carregando os pacotes necessários:

```{r message=FALSE}
#rm(list=ls()) #Removes all items in Environment!
library(FinTS) #for function `ArchTest()`
library(rugarch) #for GARCH models
library(tseries) # for `adf.test()`
library(dynlm) #for function `dynlm()`
library(vars) # for function `VAR()`
library(nlWaldTest) # for the `nlWaldtest()` function
library(lmtest) #for `coeftest()` and `bptest()`.
library(broom) #for `glance(`) and `tidy()`
#library(PoEdata) #for PoE4 datasets
library(car) #for `hccm()` robust standard errors
library(sandwich)
library(knitr) #for `kable()`
library(forecast) 
```

Vamos primeiro realizar, passo a passo, o teste ARCH na variável VALE.Close. Iremos transformar os dados numa série temporal para leitura do R:


```{r}

library(dynlm)

rTS <- ts(dlnVALEclose)

plot.ts(rTS)

```

Então obtemos os valores de estimativas dos parâmetros da regressão:

```{r}

VALE.media <- dynlm(rTS~1)

summary(VALE.media)
```

```{r}
ehatsq <- ts(resid(VALE.media)^2)

VALE.ARCH <- dynlm(ehatsq~L(ehatsq))

summary(VALE.ARCH)
```


```{r}
library(broom)

T <- nobs(VALE.media)

q <- length(coef(VALE.ARCH))-1

Rsq <- glance(VALE.ARCH)[[1]]

LM <- (T-q)*Rsq

alpha <- 0.05

quiquadr <- qchisq(1-alpha, q)
```

O valor da estatística LM é de `r round(LM,2)` que deve ser comparado ao valor crítico do qui-quadrado com $\alpha = 0,05$ e $q = 1$ grau de liberdade; este valor é $\chi^{2}$ (0,95, 1) = `r round(quiquadr,2)`; isso indica que a hipótese nula é rejeitada, concluindo que a série tem efeitos ARCH.

A mesma conclusão pode ser alcançada se, em vez do procedimento passo a passo, usarmos um dos recursos de teste ARCH do R, a função ArchTest() no pacote FinTS.

```{r}
library(FinTS)
VALEArchTest <- ArchTest(ativo2, lags=1, demean=TRUE)
VALEArchTest
```

A função garch() no pacote tseries torna-se um modelo ARCH quando usada com o argumento order = igual a c(0,1). Essa função pode ser usada para estimar e plotar a variância ht definida na Equação 3, conforme mostrado no código a seguir e na Figura a seguir.

```{r}
library(tseries)

rTS<-rTS%>%
  na.omit() # Retiro os NAs da serie

VALE.arch <- garch(rTS,c(0,1))
```


```{r}
sbydarch <- summary(VALE.arch)
sbydarch
```


```{r}
hhat <- ts(2*VALE.arch$fitted.values[-1,1]^2)

plot.ts(hhat)
```

# O modelo GARCH

```{r}
library(rugarch)
garchSpec <- ugarchspec(
           variance.model=list(model="sGARCH",
                               garchOrder=c(1,1)),
           mean.model=list(armaOrder=c(0,0)), 
           distribution.model="std")
garchFit <- ugarchfit(spec=garchSpec, data=rTS)
coef(garchFit)
```



```{r}
rhat <- garchFit@fit$fitted.values
plot.ts(rhat)
hhat <- ts(garchFit@fit$sigma^2)
plot.ts(hhat)
```

```{r}
# tGARCH 
garchMod <- ugarchspec(variance.model=list(model="fGARCH",
                               garchOrder=c(1,1),
                               submodel="TGARCH"),
           mean.model=list(armaOrder=c(0,0)), 
           distribution.model="std")
garchFit <- ugarchfit(spec=garchMod, data=rTS)
coef(garchFit)
```

```{r}
rhat <- garchFit@fit$fitted.values
plot.ts(rhat)
hhat <- ts(garchFit@fit$sigma^2)
plot.ts(hhat)
```

```{r}
# GARCH-in-mean
garchMod <- ugarchspec(
          variance.model=list(model="fGARCH",
                               garchOrder=c(1,1),
                               submodel="APARCH"),
           mean.model=list(armaOrder=c(0,0),
                          include.mean=TRUE,
                          archm=TRUE,
                          archpow=2
                          ), 
           distribution.model="std"
                           )
garchFit <- ugarchfit(spec=garchMod, data=rTS)
coef(garchFit)
```

```{r}
rhat <- garchFit@fit$fitted.values
plot.ts(rhat)
hhat <- ts(garchFit@fit$sigma^2)
plot.ts(hhat)
```

As Figuras anteriores mostram algumas versões do modelo GARCH. As previsões podem ser obtidas usando a função ugarchboot() do pacote ugarch.






*** 

### Referências

Graves, Spencer. 2014. **_FinTS: Companion to Tsay (2005) Analysis of Financial Time Series._** https://CRAN.R-project.org/package=FinTS.

Ghalanos, Alexios. 2015. **_Rugarch: Univariate Garch Models._** https://CRAN.R-project.org/package=rugarch.


